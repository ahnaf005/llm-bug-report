Title: NullPointerException in CastelProtocolDecoder.decode after inverting channel null-check

Summary
- Unit tests fail (1 error) after the recent change to CastelProtocolDecoder.java: a NullPointerException occurs in CastelProtocolDecoder.decode (line 95) during CastelProtocolDecoderTest.testDecode.
- The failure correlates to a one-line change that inverted a null-check on the Netty Channel. The inverted condition leads to code attempting to use a null Channel when running tests (which pass a null channel).

Environment
- Project: tananaev/traccar
- Failed commit SHA: 6883ecf8462e26f63d2709426c2cacf5dd318c49
- Passing commit SHA: 670acf03fb75e56fc0efc0c1fcfac04060bfb985
- Build system: Travis CI container based
- JDK: OpenJDK 1.7.0_75
- Maven: 3.2.5
- Command used: mvn test -B
- Failing test: org.traccar.protocol.CastelProtocolDecoderTest.testDecode

Failure (from build log)
- Test result summary:
  - Tests run: 92, Failures: 0, Errors: 1, Skipped: 0
  - Error in: testDecode(org.traccar.protocol.CastelProtocolDecoderTest)
- Stack trace:
  java.lang.NullPointerException
    at org.traccar.protocol.CastelProtocolDecoder.decode(CastelProtocolDecoder.java:95)
    at org.traccar.protocol.CastelProtocolDecoderTest.testDecode(CastelProtocolDecoderTest.java:20)
    ... (JUnit reflection stack)

Relevant code diff (one-line change)
- File: src/org/traccar/protocol/CastelProtocolDecoder.java
- Diff (context):
--- a/src/org/traccar/protocol/CastelProtocolDecoder.java
+++ b/src/org/traccar/protocol/CastelProtocolDecoder.java
@@ -80,7 +80,7 @@ public class CastelProtocolDecoder extends BaseProtocolDecoder {
                 return null;
             } else if (type == MSG_LOGIN) {
 
-                if (channel == null) {
+                if (channel != null) {
                     ChannelBuffer response = ChannelBuffers.directBuffer(ByteOrder.LITTLE_ENDIAN, 41);
                     response.writeByte(0x40); response.writeByte(0x40);
                     response.writeShort(response.capacity());
                     ...

Diagnosis / Root cause
- The change inverted a null-check for the Netty Channel inside the MSG_LOGIN handling block.
- Unit tests exercise the decoder with a null Channel (common test pattern to verify pure decoding logic without a network channel).
- As a result of the changed condition, execution enters a code path that assumes a non-null Channel and tries to use it (write a response), producing a NullPointerException when tests pass null for channel.
- The failing stack trace points to CastelProtocolDecoder.decode(...) — consistent with an attempt to use channel or other object that is null in that code path.

Why this is a regression
- Previously (passing SHA) the code guarded the response-writing block correctly with respect to test usage (i.e., did not attempt to write to a null channel). The single-line change inverted the guard and introduced the NPE.
- Tests that pass null for channel are a normal way to test pure decoding; decoder implementations must accept a null channel and avoid writing to it.

How to reproduce locally
1. Clone the repository at the failing commit:
   git clone --depth=50 --branch=master git://github.com/tananaev/traccar.git
   cd traccar
   git checkout 6883ecf8462e26f63d2709426c2cacf5dd318c49
2. Run the failing test:
   mvn -q -Dtest=org.traccar.protocol.CastelProtocolDecoderTest#testDecode test
3. Observe the NullPointerException reported in the surefire output or logs.

Proposed fixes
Option A — Restore intended behavior (likely correct)
- Revert the inversion: ensure the code does not try to write to the channel when the passed channel is null. The simplest correct guard is to check for non-null before writing:
  if (channel != null) {
      ChannelBuffer response = ChannelBuffers.directBuffer(ByteOrder.LITTLE_ENDIAN, 41);
      ...
      channel.write(response);
  }
- Or, if the intention is to return early in case channel is null, explicitly return before constructing/writing the response:
  if (channel == null) {
      return null; // no channel — no outbound response
  }
  // now safe to construct response and write it

Option B — Defensive guard around channel.write
- If construction of response is allowed in either case but writing must only occur when channel != null, move the channel.write(response) inside a null-check:
  ChannelBuffer response = ChannelBuffers.directBuffer(...);
  // prepare response...
  if (channel != null) {
      channel.write(response);
  }
  // otherwise drop the response or handle accordingly

Recommended change
- Ensure the decoder never calls channel.write(...) unless channel is non-null. The test indicates channel is null in unit test mode, so revert or correct the condition so channel usage is guarded.
- Example patch (safe, minimal):
  if (type == MSG_LOGIN) {
      ChannelBuffer response = ChannelBuffers.directBuffer(ByteOrder.LITTLE_ENDIAN, 41);
      response.writeByte(0x40); response.writeByte(0x40);
      response.writeShort(response.capacity());
      ...
      // Only write if channel exists (unit tests pass null)
      if (channel != null) {
          channel.write(response);
      }
  }

Additional recommendations
- Add a unit test that explicitly calls decode with a null channel to ensure no NPE (or extend existing test expected behavior).
- Add a short code comment explaining that tests call decode with a null channel and that writes must be guarded.
- Consider static analysis or an assertion in tests to detect accidental inversion of null checks in future.

Impact
- High for CI/build stability: currently Maven test stage fails causing pipeline red.
- Low risk for production runtime if fixed by guarding channel.write; however, logic for responding to login messages may be silently skipped for null channel — the unit tests rely on that.
- Priority: Immediate (fix to unblock tests and merge).

Attachments / references
- Failing build: Travis logs show the NPE and failing test (org.traccar.protocol.CastelProtocolDecoderTest).
- Diff provided in the change set (one-line modification described above).
- Passing commit SHA: 670acf03fb75e56fc0efc0c1fcfac04060bfb985
- Failing commit SHA: 6883ecf8462e26f63d2709426c2cacf5dd318c49

If you'd like, I can:
- Propose the exact patch text to apply (revert or insert guard) and format it as a git patch.
- Run through likely unit test adjustments and provide a test snippet to add.