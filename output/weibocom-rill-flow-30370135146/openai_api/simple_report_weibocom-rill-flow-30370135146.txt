Bug report: Failure in olympicene-traversal tests caused by ExecutionResult.taskStatus being null in AnswerTaskRunner

Summary
- Build failing on CI: module olympicene-traversal fails unit test suite.
- Failing test: com.weibo.rill.flow.olympicene.traversal.runners.AnswerTaskRunnerTest.test doRun when answerTask is null
- Symptom: Assertion expecting ExecutionResult.taskStatus == TaskStatus.SKIPPED fails because result.taskStatus is null.
- Root cause: ExecutionResult was built from taskInfo.getTaskStatus(), but in the code path for "answer task missing / empty expression" the taskInfo.taskStatus was never set, so the returned ExecutionResult.taskStatus became null.
- Fix (applied in patch): build the ExecutionResult using the local retStatus variable (which has been set to SKIPPED/FAILED/SUCCEED) instead of reading taskInfo.getTaskStatus(). This ensures a non-null returned taskStatus.
- Recommended additional improvement: keep TaskInfo state consistent by setting taskInfo.setTaskStatus(retStatus) where appropriate (so object state and returned result match).

Build environment & context
- CI runner: ubuntu-22.04 (actions runner)
- Java: Temurin JDK 17.0.12+7
- Maven: executed "mvn -B clean javadoc:javadoc verify org.sonarsource.scanner.maven:sonar-maven-plugin:sonar -P coverage -Dsonar.projectKey=weibocom_rill-flow"
- Failed commit SHA: c2f1d53ae37c0ee40ce5b27e9152d329c47acb23 (logged as failed_sha in code diff metadata)
- Failing module: rill-flow-dag/olympicene-traversal

Relevant failure log excerpts
- Failed test summary:
  - [ERROR] com.weibo.rill.flow.olympicene.traversal.runners.AnswerTaskRunnerTest.test doRun when answerTask is null  Time elapsed: 0.536 s  <<< FAILURE!
- Assertion failure and ExecutionResult printed:
  - Condition not satisfied:
    result.taskStatus == TaskStatus.SKIPPED
    |      |          |  |
    |      null       |  class com.weibo.rill.flow.interfaces.model.task.TaskStatus
    |                 false
    <com.weibo.rill.flow.olympicene.core.model.task.ExecutionResult@545dedf4 needRetry=false retryIntervalInSeconds=0 taskStatus=null context=null input=null taskInfo=null dagInfo=null subTaskInfosAndContext=null taskNameNeedToTraversal=null>
  - This shows ExecutionResult.taskStatus == null at assert time.

Stack traces & logs (key lines)
- Test failure location:
  - AnswerTaskRunnerTest.groovy:48 (assertion fails here)
- Additional diagnostic log earlier:
  - ERROR com.weibo.rill.flow.olympicene.traversal.runners.FunctionTaskRunner - dispatchTask fails ... (not directly related to failing unit assertion, but appears in logs)
- Build finished with:
  - [ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:3.0.0-M6:test ... There are test failures.

Root cause analysis
- In AnswerTaskRunner.doRun (simplified flow), when the answer task expression is empty:
  - Code creates a TaskInvokeMsg, updates taskInfo.invokeMsg
  - retStatus is set to TaskStatus.SKIPPED
  - The method previously returned ExecutionResult.builder().taskStatus(taskInfo.getTaskStatus()).build()
- Problem: taskInfo.getTaskStatus() was not updated in that branch, so it remained null. Therefore the ExecutionResult had a null taskStatus and the test that expects SKIPPED failed.
- The root cause is a mismatch between:
  - the local variable retStatus (which correctly reflects the intended return status), and
  - the taskInfo object which was not updated to the same status in that branch.
- Because the code returned taskInfo.getTaskStatus() rather than retStatus, the returned ExecutionResult could be null.

Code diff (applied change)
- File modified:
  - rill-flow-dag/olympicene-traversal/src/main/java/com/weibo/rill/flow/olympicene/traversal/runners/AnswerTaskRunner.java
- Patch summary (relevant hunks):
  - Previously:
      return ExecutionResult.builder().taskStatus(taskInfo.getTaskStatus()).build();
    Changed to:
      return ExecutionResult.builder().taskStatus(retStatus).build();
  - Also replaced a later return that used taskInfo.getTaskStatus() with retStatus:
      return ExecutionResult.builder().taskStatus(retStatus).build();
- This change prevents returning a null taskStatus when taskInfo.taskStatus has not been updated.

Why the patch fixes the failing test
- The test expects ExecutionResult.taskStatus to be SKIPPED in the "answerTask is null" case. The local variable retStatus is set to SKIPPED in that branch. Returning retStatus directly ensures the ExecutionResult has SKIPPED (non-null), satisfying the assertion.
- The previous behavior returned taskInfo.getTaskStatus(), which was null and thus triggered the failure.

Recommended formal fix (and improvement)
- The applied change (return retStatus instead of taskInfo.getTaskStatus()) is necessary and addresses the observed null value.
- Additionally, to keep TaskInfo consistent with the result and avoid future divergence:
  - In the branch where retStatus is set (e.g., SKIPPED, FAILED), also set taskInfo.setTaskStatus(retStatus).
  - This ensures the TaskInfo object and returned ExecutionResult are consistent and reduces the chance of similar bugs later.
- Example (pseudo-code) for the "empty answer expression" branch:
    TaskInvokeMsg taskInvokeMsg = TaskInvokeMsg.builder().msg("answer task expression empty").build();
    taskInfo.updateInvokeMsg(taskInvokeMsg);
    retStatus = TaskStatus.SKIPPED;
    taskInfo.setTaskStatus(retStatus); // <- keep object state consistent
    return ExecutionResult.builder().taskStatus(retStatus).build();

Suggested unit test additions
- Ensure the existing test verifies both the returned ExecutionResult.taskStatus and that taskInfo.getTaskStatus() is updated:
    when:
      ExecutionResult result = answerTaskRunner.doRun(executionId, taskInfo, input)
    then:
      result.taskStatus == TaskStatus.SKIPPED
      taskInfo.getTaskStatus() == TaskStatus.SKIPPED
- Add a test that validates for failure/tolerance branch (retStatus = FAILED or SKIPPED depending on tolerance) that both returned status and taskInfo are updated consistently.

Reproduction steps (local)
1. Checkout the failing SHA or code before the patch (the commit that caused CI failure).
2. Run only the failing test or module to reproduce quickly:
   - mvn -pl rill-flow-dag/olympicene-traversal -Dtest=com.weibo.rill.flow.olympicene.traversal.runners.AnswerTaskRunnerTest#testDoRunWhenAnswerTaskIsNull test
   - or run full module tests:
     mvn -pl rill-flow-dag/olympicene-traversal test
3. Observe the failing assertion showing ExecutionResult.taskStatus == null.

Impact
- Unit test failure prevents CI pipeline from passing and blocks merges / releases.
- The issue indicates inconsistent in-memory state: a mismatch between return values and model objects. This could potentially cause runtime inconsistencies outside tests as well (other code reading taskInfo after execution might see null/incorrect status).

Risk & regression analysis
- The change is small (two return expressions changed to use retStatus).
- Risk is low for behavioral regressions because retStatus is the authoritative local variable representing intended outcome in all branches.
- Minor risk: if other code relies on taskInfo having been updated but it is not (i.e., we didn't set taskInfo.setTaskStatus in the empty branch), then additional inconsistency remains. Therefore it's recommended to also set taskInfo.setTaskStatus(retStatus) in those branches.

Recommended next steps
1. Merge the patch that returns retStatus (as in the diff).
2. Update code to set taskInfo.setTaskStatus(retStatus) in branches where retStatus is assigned but taskInfo was not updated, for consistency.
3. Add/adjust unit tests to assert both ExecutionResult.taskStatus and taskInfo.getTaskStatus.
4. Re-run the full test suite for olympicene-traversal and entire reactor build locally.
5. Monitor for other places where ExecutionResult is constructed from taskInfo.getTaskStatus()â€”replace with retStatus where appropriate or ensure taskInfo is updated before use.

Patch reference (from provided CODE DIFF)
- Patch modifies AnswerTaskRunner returns to use retStatus for ExecutionResult.taskStatus instead of taskInfo.getTaskStatus.
- Diff excerpt:
  - return ExecutionResult.builder().taskStatus(retStatus).build();
  - replaces earlier returns that used taskInfo.getTaskStatus()

Conclusion
- The CI failure is reproducible and caused by returning taskInfo.getTaskStatus() which was null in a branch where taskInfo wasn't updated. The applied change returning the local retStatus fixes the failing unit test.
- For best practice, also update taskInfo (taskInfo.setTaskStatus(retStatus)) so object state matches returned value and add unit assertions verifying both.

If you want, I can:
- Propose the exact code snippet to also set taskInfo.setTaskStatus(retStatus) in the relevant branch(es).
- Provide a concrete unit test (Groovy / Spock) patch to assert both returned ExecutionResult and taskInfo state.